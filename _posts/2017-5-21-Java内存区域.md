---
layout:     post
title:      "Java内存区域"
subtitle:   "从知道不知道到知道知道。"
date:       2017-05-21 11:00:00
author:     "Jianxin Guo"
header-img: "img/post-bg-01.jpg"
--- 

java虚拟机(jvm)之所以要划分这么多区域出来是因为这些区域都有自己的用途,以及创建和销毁的时间.有的区域则依赖用户线程的启动和结束而创建和销毁.

<a href="#">
    <img src="{{ site.baseurl }}/img/jvm01.png" alt="Post Sample Image">
</a>

<h2 class="section-heading">线程独有的内存区域</h2>
1.PROGRAM COUNTER REGISTER,程序计数器
这块内存区域很小,它是当前线程所执行的字节码的行号指示器,字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令.
2.JAVA STACK,虚拟机栈
生命周期和线程相同.每个方法执行的同时都会创建一个栈帧,用于存储局部变量表,方法出口灯信息,每一个方法从调用直至执行完毕的过程,就对应一个栈帧在虚拟机中入栈到出栈的过程,栈的大小和具体JVM实现有关,通常在256K~756K,一般不会超过1M.
3.NATIVE METHOD STACK,f方法栈
和虚拟机栈起的作用一样,只不过方法栈为虚拟机使用到的NATIVE方法服务,虚拟机规范并没有对这个区域有什么强制跪地,因此我们使用的HotSpot虚拟机,就干脆没有这块区域了,他和虚拟机栈是一起的.

<h2 class="section-heading">线程间共享的内存区域</h2>
1.heap,堆
大多数应用,堆都是java虚拟机所管理的内存中最大的一块,他在虚拟机启动时创建,此内存唯一的目的就是存放对象实例.由于现在垃圾收集器采用的基本都是分代收集算法,所以堆还可以细分为新生代和老年代,再细一点,新生代还可以分为Eden区,From Survivior区,To Survivor区.
2.METHOD AREA,方法区
这块区域用于存储虚拟机加载的类信息,常量,静态变量,即时编译器后的代码等数据,虚拟机规范是把这块区域描述为堆的一个逻辑部门的,但实际它应该是要和堆区分开的.从上面提到的分代收集算法的角度看,HotSpot中,方法区≈永久代.不过JDK7之后,我们使用的HotSpot应该就没有永久代这个概念了,会采用Native Memory来实现方法区的规划了.
3.RUNTIME CONSTANT POOL,运行时常量池
上面的图没有画出来,因为它是方法区的一部分.Class文件中除了有类的版本信息,字段,方法,接口等描述信息外,还有一项信息就是常量池,用于存放编译期间生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行常量池中,另外翻译出来的直接引用也会存储在这个区域中.这个区域另外一个特点就是动态性,java并不要求常量就一定在编辑期间才能产生,运行期间也可以在这个却与放入新的内容,String.intern()方法就是这个特性的应用.


