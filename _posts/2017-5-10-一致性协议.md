---
layout:     post
title:      "一致性算法"
subtitle:   "从知道不知道到知道知道。"
date:       2017-05-10 11:00:00
author:     "Jianxin Guo"
header-img: "img/post-bg-01.jpg"
--- 
<h2 class="section-heading">2PC与3PC与Paxos</h2>

在分布式系统中，每一个机器节点虽然都能够明确地知道自己在进行事务操作过程中的结果是成功或失败，但却无法直接获取到其他分布式节点的操作结果。因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性，就需要引入一个称为"协调者（Coordinator）"的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为"参与者（Participant）"。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正提交。基于这种思想，衍生出了二阶段提交和三阶段提交两种协议，下面先讲讲二阶段提交和三阶段提交。

<h2 class="section-heading">2PC</h2>

2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。

1、阶段一：提交事物请求

（1）事务询问

协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各个参与者的响应

（2）执行事务

各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中

（3）各个参与者向协调者反馈事务询问的响应

如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行

由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投票表态过程，因此二阶段提交协议的阶段一也被称为"投票阶段"，即各参与者投票表明是否要继续执行接下去的事务提交操作

2、阶段二：执行事务提交

在阶段二中协调者会根据各参与者的反馈来决定是否最终可以进行事务提交操作，正常情况下包含两种可能：

（1）执行事务提交

假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交：

　　a）发送提交请求

　　　　协调者向所有参与者节点发出Commit请求

　　b）事务提交

　　　　参与者收到Commit请求后会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源

　　c）反馈事务提交操作

　　　　参与者在完成事务提交之后，向协调者发送Ack消息

　　d）完成事务

　　　　协调者收到所有参与反馈的Ack消息后完成事务

（2）中断事务

假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事物。

　　a）发送回滚请求

　　　　协调者向所有参与者节点发出Rollback请求

　　b）事物回滚

　　　　参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事物执行期间占用的资源

　　c）反馈事务回滚结果

　　　　参与者在完成事物回滚之后，向协调者发送Ack消息

　　d）中断事物

　　　　协调者接收到所有参与者反馈的Ack消息后，完成事物中断

以上就是二阶段提交过程中，前后两个阶段分别进行的处理逻辑。简单讲，二阶段提交尝试讲一个事物的处理过程分为了投票和执行两个阶段，其核心是对每个事物都采取先尝试后提交的方式，因此也可以将二阶段提交看作是一个强一致性的算法。"事物提交"和"事物中断"两种场景分别如图所示：


<a href="#">
    <img src="{{ site.baseurl }}/img/2pc01.png" alt="Post Sample Image">
</a>

<a href="#">
    <img src="{{ site.baseurl }}/img/2pc02.png" alt="Post Sample Image">
</a>

 

2PC的优缺点

1、二阶段提交协议的优点：

原理简单、实现方便

2、二阶段提交协议的缺点，重点讲一下：

（1）同步阻塞

二阶段提交协议存在的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事物操作的逻辑都处于阻塞状态，也就是说每个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作

（2）单点问题

从上面的讲解以及上图中可以看出，协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将一直处于锁定事物资源的状态中，而无法继续完成事物操作

（3）数据不一致

在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事物提交，于是整个分布式系统便出现了数据不一致的现象

（4）太过保守

如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事物，这样的策略显得比较保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事物的失败

 

<h2 class="section-heading">3PC</h2>

2PC在其实际运行过程中可能存在诸如同步阻塞、协调者的单点问题、脑裂和太过保守的容错机制等缺点，因此研究者在二阶段提交协议的基础上进行了改进，提出了三阶段提交协议。

3PC，是Three-Phase Commit的缩写，即三阶段提交协议，是2PC的改进版本，其将二阶段提交协议的"提交事物请求"过程一分为二，并形成了由CanCommit、PreCommit和do Commit三个阶段组成的事物处理协议，从维基百科上拿一张图下来看一下三阶段提交协议流程示意图

<a href="#">
    <img src="{{ site.baseurl }}/img/3pc.png" alt="Post Sample Image">
</a>



1、阶段一：CanCommit

（1）事物询问

协调者向所有的参与者发送一个包含事物内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应

（2）各参与者向协调者反馈事务询问的响应

参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应

2、阶段二：PreCommit

在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能：

（1）执行事务预提交

假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。

　　a）发送预提交请求

　　　　协调者向参与者节点发出preCommit的请求，进入Prepared阶段

　　b）事务预提交

　　　　参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中

　　c）各参与者向协调者反馈事务执行的响应　　

　　　　如果参与者成功执行了事务操作，哪儿就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）

（2）中断事物

假如任何一个参与者向协调者反馈了No响应，或者在等待超时后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事物。

　　a）发送中断请求

　　　　协调者向所有参与者节点发出abort请求

　　b）中断事物

　　　　无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事物

3、阶段三：doCommit

该阶段将进行真正的事物提交，会存在以下两种可能的情况：

（1）执行提交

　　a）发送提交请求

　　　　进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从"预提交"状态转换到"提交"状态，并向所有的参与者发送doCommit请求

　　b）事物提交

　　　　参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事物执行期间占用的事物资源

　　c）反馈事物提交结果

　　　　参与者在完成事物提交之后，向协调者发送Ack消息

　　d）完成事物

　　　　协调者接收到所有参与者反馈的Ack消息后，完成事物

（2）中断事物

进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者商无法接收到所有参与者的反馈响应，那么就会中断事物

　　a）发送中断请求

　　　　协调者向所有的参与者节点发送abort请求

　　b）事物回滚

　　　　参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成事物回滚之后释放在整个事物执行期间所占用的资源

　　c）反馈事务反馈结果

　　　　参与者在完成事物回滚之后，向协调者发送Ack消息

　　d）中断事物

　　　　协调者接收到所有参与者反馈的Ack消息后，中断事物

需要注意的是，一旦进入阶段三，可能会出现以下两种故障：

协调者出现问题
协调者和参与者之间的网络故障
无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或者是abort请求，针对这样的异常情况，参与则都会在等待超时之后，继续进行事务提交

 

3PC的优缺点

1、三阶段提交的优点

相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致

2、三阶段提交的缺点

三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果出现网络分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，参与者依然会进行事物的提交，这必然出现数据的不一致

我们可以看以，这似乎就是一个“两段提交”的优化。其实，2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。


<h2 class="section-heading">Paxos</h2>


基于消息传递且具有高度容错性的一致性算法。Paxos算法要解决的问题就是如何在可能发生机器宕机或网络异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。

拜占庭问题：消息不完整或者被篡改。Paxos在维持领导者选举或者变量修改一致性上，采取一种类似议会投票的过半同意机制，比如设定一个领导者，需要将此看做一个议案，征求过半同意，每个节点通过一个议案会有编号记录，再次收到此领导者的不同人选，发现已经有编号记录便驳回，最后以多数通过的结果为准。

我们举个简单的例子，来阐述一下Paxos的基本思想：假设我们有5台计算机A、B、C、D、E，每台计算机保存着公司CEO的信息，现在CEO任期到了，需要进行新一界选举了。

A计算机发起一个选举议案，提议CEO为“张三”，如果没有其他候选人议案，也没有网络问题，只要其中半数以上计算机收到并通过议案，那么最终“张三”当选CEO。由于是分布式环境，并发请求、机器故障、网络故障等问题是常态，如果A和E同时提交选举议案，A提名“张三”，E提名“李四”，那么肯定会涉及多计算机的一致性问题了：假设A、B、C先收到A的议案，D、E先收到E的议案，那么A继续提交给D时，D告诉它已经先收到E的议案了，因此驳回了A的请求。同样E继续提交给A、B、C时也碰到相同的问题。

我们可以通过“在每台计算机同时接受议案提交时设置一个编号，编号先的通过，编号后的驳回”的方式来实现。议案提交上去后，发现A、B、C投票“张三”为CEO，D、E投票“李四”为CEO，少数服从多数，因此最后结果为“张三”当选CEO。

<a href="#">
    <img src="{{ site.baseurl }}/img/paxos.png" alt="Post Sample Image">
</a>


如果是C计算机发生了网络问题或者故障，双方投票相同，那么选举无法完成。

如果C计算机发生了网络问题或者故障，A、B、D投票“张三”，E投票“李四”，那么结果为“张三”当选，而C对于这些情况一无所知，但是当C计算机恢复正常时，他会发起一个“询问谁是CEO”的议案获取最新信息。简言之，Paxos对每个节点的并发修改采取编号记录的方式保持一致性，对多个节点的并发修改采取少数服从多数的方式保持一致性。Paxos有点类似分布式二阶段提交方式，但是又不同，二阶段提交不能是多数节点同意，必须是全部同意。为了遵守过半节点同意的约束，Paxos算法往往要求节点总数为奇数。

Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。

简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。

这个算法有两个阶段（假设这个有三个结点：A，B，C）：

第一阶段：Prepare阶段
A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。

如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），并保证不接收其它<n的提案。这样一来，结点上在Prepare阶段里总是会对最新的提案做承诺。

优化：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。

第二阶段：Accept阶段
如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。

当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会通过request（修改这个值），如果发现自己有一个更大的提案号，那么，结点就会拒绝request（拒绝修改）。

我们可以看以，这似乎就是一个“两段提交”的优化。其实，2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。

我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。

